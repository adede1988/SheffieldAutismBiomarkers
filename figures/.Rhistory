source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
x = seq(1,10000, 10)
y = (999/1000)^x
plot(y)
y2 = (999999/1000000)^x
plot(y2)
plot(y, xlab = 'routes climbed', ylab = 'prob of anchor failure')
plot(y, xlab = 'routes climbed', ylab = 'prob of anchor failure', main = 'single sling 1/1000 break')
plot(y2, xlab = 'routes climbed', ylab = 'prob of anchor failure', main = 'double sling 1/1000000 break')
plot(y2, xlab = 'routes climbed', ylab = 'prob of anchor failure', main = 'double sling 1/1000000 break', ylim = c(0,1))
plot(y, xlab = 'routes climbed', ylab = 'prob of anchor failure', main = 'single sling 1/1000 break')
library(lsr)
library(tidyverse)
library(car)
library(circular)
library(kableExtra)
test <- read.csv("C:\\Users\\Adam Dede\\Documents\\GitHub\\SheffieldAutismBiomarkers\\autismBiomarkersAllData2.csv")
test$nbChanOrig[test$nbChanOrig==999] = 124 #due to a data import error, less than 10 participants had their nbChanOrig values missing
dat <- filter(test, group %in% c('CON', 'AD', 'ASD'), eyes == 'open')
sum(dat$group=='AD' & dat$age > 250)
sum(dat$group=='AD' & dat$age <= 250)
dat <- filter(dat, age<=250)
dat <- filter(dat, nbChanOrig>20)
dat <- filter(dat, nbChanFinal/nbChanOrig >= .5)
sum(is.na(dat$IQ))
dataSumTable = data.frame('group' = rep(c('AD', 'ASD', 'CON')),
'data set' = as.vector(apply(as.matrix(unique(dat$dataSet)), 1, function(x) rep(x, 3))),
'IQ' = rep('', 15),
'IQ metric' = c(rep('DAS GCA', 3), rep('MSEL', 3), rep('WTAR', 3), rep('DAS GCA', 3), rep('WTAR', 3)),
'age' = rep('', 15),
'n female' = rep('', 15),
'n total' = rep('', 15),
'orig channels' = rep('', 15),
'final channels' = rep('', 15),
'orig epochs' = rep('', 15),
'final epochs' = rep('', 15))
for(ii in 1:15) {
cur = filter(dat, group == dataSumTable$group[ii], dataSet == dataSumTable$data.set[ii])
if(length(cur$age) > 0){
dataSumTable$IQ[ii] = paste(round(mean(cur$IQ, na.rm = T)), ' (', round(sd(cur$IQ, na.rm = T)), ')', sep='')
dataSumTable$age[ii] = paste(round(mean(cur$age)), ' (', round(sd(cur$age)), ')', sep='')
dataSumTable$n.female[ii] = sum(cur$sex == 'F')
dataSumTable$n.total[ii] = length(cur$sex)
dataSumTable$orig.channels[ii] = paste(round(mean(cur$nbChanOrig)), ' (', round(sd(cur$nbChanOrig)), ')', sep='')
dataSumTable$final.channels[ii] = paste(round(mean(cur$nbChanFinal)), ' (', round(sd(cur$nbChanFinal)), ')', sep='')
dataSumTable$orig.epochs[ii] = paste(round(mean(cur$nbTrialOrig)), ' (', round(sd(cur$nbTrialOrig)), ')', sep='')
dataSumTable$final.epochs[ii] = paste(round(mean(cur$nbTrialFinal)), ' (', round(sd(cur$nbTrialFinal)), ')', sep='')
#replace na IQ values
dat$IQ[dat$group == dataSumTable$group[ii] & dat$dataSet == dataSumTable$data.set[ii] & is.na(dat$IQ)] = mean(cur$IQ, na.rm = T)
}
}
dataSumTable %>%
kbl(align = 'c') %>%
kable_classic(full_width = F,
font_size = 20) %>%
row_spec(1, align = 'c')%>%
footnote(general = "DAS GCA = Differential Ability Scales General Conceptual Ability
MSEL = Mullen Scales of Early Learning
WTAR = Weschler Test of Adult Reading
biomarkCon = The Autism Biomarkers Consortium for Clinical Trials
biomarkDev = Biomarkers of Developmental Trajectories and Treatment in ASD
bpSZ = Bipolar & Schizophrenia Consortium for Parsing Intermediate Phenotypes
femaleASD = Multimodal Developmental Neurogenetics of Females with ASD
socBrain = The Social Brain in Schizophrenia and Autism Spectrum Disorders
Numeric values indicate mean and (standard deviation).",
general_title = "Table 1: ",
footnote_as_chunk = T, title_format = c("italic", "underline")
)
setwd("C:\\Users\\Adam Dede\\Documents\\GitHub\\SheffieldAutismBiomarkers\\figures")
ageGroups = quantile(filter(dat, group %in% c('AD', 'ASD'))$age , c(0,.33333,.666666,1.0))
ageGroups[1]= 0
ageGroups[4]=999
dat = read.csv("C:\\Users\\Adam Dede\\Documents\\GitHub\\SheffieldAutismBiomarkers\\trainSet.csv")
dat <- dat %>% select(-X)
varNames = names(dat)[20:1179]
results = data.frame('dependentVariable' = rep('A', 4*length(varNames)),
'age' = rep(0, 4*length(varNames)),
'sex' = rep(0, 4*length(varNames)),
'IQ' = rep(0, 4*length(varNames)),
'Diag' = rep(0, 4*length(varNames)),
'age_b' = rep(0, 4*length(varNames)),
'sex_b' = rep(0, 4*length(varNames)),
'IQ_b' = rep(0, 4*length(varNames)),
'diag_b1' = rep(0, 4*length(varNames)),
'diag_b2' = rep(0, 4*length(varNames)),
'n' = rep(0, 4*length(varNames)),
'out' = rep(0, 4*length(varNames)),
'ageGroup' = rep(0, 4*length(varNames)))
for(ii in 2:length(ageGroups)){
#down select for age
curDat = dat[dat$age>ageGroups[ii-1] & dat$age<ageGroups[ii], ]
#down select for group ID
# curDat = curDat[curDat$group == 'CON' | curDat$group == 'AD' |curDat$group == 'ASD',]
groupID = rep(1,length(curDat$group))
#running the analysis with AD and ASD as a single group
groupID[curDat$group=='AD'] = 3
groupID[curDat$group=='ASD'] = 2
for(tt in 1:length(varNames)){
if(!grepl('PACmi', varNames[tt] )) { #skipping the non z-scored raw PAC values
print(tt)
temp = curDat
#### outlier removal ####
#after beginning analysis, it was discovered that some variables contained
#extreme outliers such that one or two variables were far above the mean
#and all other variables were below the mean.
#in these cases, simply eliminating outliers based on a standard z-score
#would have eliminated all variables since the mean ended up in a position
#far from any data points. To get around this, data were z scored using only
#the middle 80% of the data. Then, based on this z-scoring, outliers were removed
if(!grepl('phase', varNames[tt])){
keep = !is.na(curDat[[varNames[tt]]])
temp = temp[keep,]
dv = temp[[varNames[tt]]]
n = length(dv)
lims = quantile(dv, c(.1, .90))
dv_mean = mean(dv[dv>lims[1] & dv<lims[2]])
dv_sd = sd(dv[dv>lims[1] & dv<lims[2]])
dv_z = (dv - dv_mean) / dv_sd
nonOut = which(abs(dv_z)<5)
dv_mean = mean(dv[nonOut])
dv_sd = sd(dv[nonOut])
dv_z = (dv - dv_mean) / dv_sd
dv = dv[abs(dv_z)<5]
age = temp$age[abs(dv_z)<5]
sex = temp$sex[abs(dv_z)<5]
IQ = temp$IQ[abs(dv_z)<5]
IQ[is.na(IQ)] = 100
gID = groupID[keep]
ID = gID[abs(dv_z)<5]
#standardizing the dependent variable prior to model calculation
#it was discovered after data analysis began that many values, particularly
#PAC values could not easily be fit because values were so small that floating
#point precision had a problem. To get around this, all variables were z-scored
#prior to model fitting. Mean and standard deviation are stored so that beta
#weights can be converted back later if necessary
dv_mean = mean(dv)
dv_sd = sd(dv)
dv = (dv - dv_mean) / dv_sd
}else{
dv_sd = 1
dv_mean = 0
keep = !is.na(curDat[[varNames[tt]]])
temp = temp[keep,]
dv = temp[[varNames[tt]]]
age = temp$age
sex = temp$sex
IQ = temp$IQ
IQ[is.na(IQ)] = 100
ID = groupID[keep]
}
modDat = data.frame('dv' = dv, 'age' = age, 'sex' = factor(sex), 'IQ' = IQ, 'diag' = factor(ID))
# outPlot <- ggplot(modDat, aes(x = age, y = dv*dv_sd + dv_mean, color = diag, shape = sex, size = IQ)) +
#   geom_jitter()+
#   scale_color_manual(values=c("#4E554E", "#3BACDD", "#E1C271"),
#                        labels=c('CON', 'ASD', 'AD')) +
#   theme_classic() +
#   theme(axis.line = element_line(color = 'black', size = 3),
#         axis.ticks = element_line(colour = "black", size = 2),
#         axis.ticks.length=unit(-.25, "cm"),
#         text = element_text(size = 20)) +
#   ylab(varNames[tt]) +
#   ggtitle(paste(varNames[tt], '; age group: ', as.character(ii-1), sep = ''))+
#   guides(color = guide_legend(override.aes = list(size=10)),
#          shape = guide_legend(override.aes = list(size=10)))
# # rect(1, 5, 3, 7, col="white")
# png(paste(varNames[tt], '_', ii-1, '.png', sep = ''),         # File name
#     width=1024, height=768)
# print(outPlot)
# dev.off()
if(!grepl('phase', varNames[tt])){
curLM = lm(dv ~ age + sex + diag  +IQ , data = modDat)
aovTab = Anova(curLM, type = 3)
ai = (ii-2)*length(varNames)
results[tt+ai,1] = varNames[tt]
ei = which(row.names(aovTab) == 'Residuals')
ri = which(row.names(aovTab) == 'diag')
results$Diag[tt+ai] = aovTab$`Sum Sq`[ri] / (aovTab$`Sum Sq`[ri] + aovTab$`Sum Sq`[ei])
ri = which(row.names(aovTab) == 'sex')
results$sex[tt+ai] = aovTab$`Sum Sq`[ri] / (aovTab$`Sum Sq`[ri] + aovTab$`Sum Sq`[ei])
ri = which(row.names(aovTab) == 'IQ')
results$IQ[tt+ai] = aovTab$`Sum Sq`[ri] / (aovTab$`Sum Sq`[ri] + aovTab$`Sum Sq`[ei])
ri = which(row.names(aovTab) == 'age')
results$age[tt+ai] = aovTab$`Sum Sq`[ri] / (aovTab$`Sum Sq`[ri] + aovTab$`Sum Sq`[ei])
ri = which(names(curLM$coefficients) == 'age')
results$age_b[tt+ai] = curLM$coefficients[[ri]]
ri = which(names(curLM$coefficients) == 'sexM')
results$sex_b[tt+ai] = curLM$coefficients[[ri]]
ri = which(names(curLM$coefficients) == 'IQ')
results$IQ_b[tt+ai] = curLM$coefficients[[ri]]
ri = which(names(curLM$coefficients) == 'diag2')
results$diag_b1[tt+ai] = curLM$coefficients[[ri]]
ri = which(names(curLM$coefficients) == 'diag3')
results$diag_b2[tt+ai] = curLM$coefficients[[ri]]
}else { #phase needs to be treated differently because it's circular
circdv = circular(dv, unit = 'degrees')
dv_mean =  mean(circdv)[[1]]
dv_sd = sd(circdv)[[1]]
test = cbind(cos(dv*(pi/180)), sin(dv*(pi/180)))
curLM = lm(test ~ modDat$age + modDat$sex + modDat$diag  + modDat$IQ )
aovTab = Anova(curLM, type = 3)
outtests <- car:::print.Anova.mlm
body(outtests)[[16]] <- quote(invisible(tests))
body(outtests)[[15]] <- NULL
tab <- lapply(c("Pillai"),
function(i)  outtests(Anova(curLM, test.statistic=i)))
tab <- do.call(rbind, tab)
#working out effect size for diag
ai = (ii-2)*length(varNames)
ri = which(grepl('diag', row.names(tab)))
results[tt+ai,1] = varNames[tt]
results$Diag[tt+ai] = (tab$Df[1] * tab$`approx F`[ri]) /
(tab$Df[ri] * tab$`approx F`[ri] + tab$`den Df`[ri])
ri = which(grepl('sex', row.names(tab)))
results$sex[tt+ai] = (tab$Df[1] * tab$`approx F`[ri]) /
(tab$Df[ri] * tab$`approx F`[ri] + tab$`den Df`[ri])
ri = which(grepl('IQ', row.names(tab)))
results$IQ[tt+ai] = (tab$Df[1] * tab$`approx F`[ri]) /
(tab$Df[ri] * tab$`approx F`[ri] + tab$`den Df`[ri])
ri = which(grepl('age', row.names(tab)))
results$age[tt+ai] = (tab$Df[1] * tab$`approx F`[ri]) /
(tab$Df[ri] * tab$`approx F`[ri] + tab$`den Df`[ri])
}
#shared outputs for phase and other
results$n[tt+ai] = n
results$out[tt+ai] = n-length(dv)
results$ageGroup[tt+ai] = ii-1
results$dvMean[tt+ai] = dv_mean
results$dvSD[tt+ai] = dv_sd
}
}
}
resultsTRAIN = results
#### now get the same set of results but from the test set!
dat = read.csv("C:\\Users\\Adam Dede\\Documents\\GitHub\\SheffieldAutismBiomarkers\\testSet.csv")
dat <- dat %>% select(-X)
varNames = names(dat)[20:1179]
results = data.frame('dependentVariable' = rep('A', 4*length(varNames)),
'age' = rep(0, 4*length(varNames)),
'sex' = rep(0, 4*length(varNames)),
'IQ' = rep(0, 4*length(varNames)),
'Diag' = rep(0, 4*length(varNames)),
'age_b' = rep(0, 4*length(varNames)),
'sex_b' = rep(0, 4*length(varNames)),
'IQ_b' = rep(0, 4*length(varNames)),
'diag_b1' = rep(0, 4*length(varNames)),
'diag_b2' = rep(0, 4*length(varNames)),
'n' = rep(0, 4*length(varNames)),
'out' = rep(0, 4*length(varNames)),
'ageGroup' = rep(0, 4*length(varNames)))
for(ii in 2:length(ageGroups)){
#down select for age
curDat = dat[dat$age>ageGroups[ii-1] & dat$age<ageGroups[ii], ]
#down select for group ID
# curDat = curDat[curDat$group == 'CON' | curDat$group == 'AD' |curDat$group == 'ASD',]
groupID = rep(1,length(curDat$group))
#running the analysis with AD and ASD as a single group
groupID[curDat$group=='AD'] = 3
groupID[curDat$group=='ASD'] = 2
for(tt in 1:length(varNames)){
if(!grepl('PACmi', varNames[tt] )) { #skipping the non z-scored raw PAC values
print(tt)
temp = curDat
#### outlier removal ####
#after beginning analysis, it was discovered that some variables contained
#extreme outliers such that one or two variables were far above the mean
#and all other variables were below the mean.
#in these cases, simply eliminating outliers based on a standard z-score
#would have eliminated all variables since the mean ended up in a position
#far from any data points. To get around this, data were z scored using only
#the middle 80% of the data. Then, based on this z-scoring, outliers were removed
if(!grepl('phase', varNames[tt])){
keep = !is.na(curDat[[varNames[tt]]])
temp = temp[keep,]
dv = temp[[varNames[tt]]]
n = length(dv)
lims = quantile(dv, c(.1, .90))
dv_mean = mean(dv[dv>lims[1] & dv<lims[2]])
dv_sd = sd(dv[dv>lims[1] & dv<lims[2]])
dv_z = (dv - dv_mean) / dv_sd
nonOut = which(abs(dv_z)<5)
dv_mean = mean(dv[nonOut])
dv_sd = sd(dv[nonOut])
dv_z = (dv - dv_mean) / dv_sd
dv = dv[abs(dv_z)<5]
age = temp$age[abs(dv_z)<5]
sex = temp$sex[abs(dv_z)<5]
IQ = temp$IQ[abs(dv_z)<5]
IQ[is.na(IQ)] = 100
gID = groupID[keep]
ID = gID[abs(dv_z)<5]
#standardizing the dependent variable prior to model calculation
#it was discovered after data analysis began that many values, particularly
#PAC values could not easily be fit because values were so small that floating
#point precision had a problem. To get around this, all variables were z-scored
#prior to model fitting. Mean and standard deviation are stored so that beta
#weights can be converted back later if necessary
dv_mean = mean(dv)
dv_sd = sd(dv)
dv = (dv - dv_mean) / dv_sd
}else{
dv_sd = 1
dv_mean = 0
keep = !is.na(curDat[[varNames[tt]]])
temp = temp[keep,]
dv = temp[[varNames[tt]]]
age = temp$age
sex = temp$sex
IQ = temp$IQ
IQ[is.na(IQ)] = 100
ID = groupID[keep]
}
modDat = data.frame('dv' = dv, 'age' = age, 'sex' = factor(sex), 'IQ' = IQ, 'diag' = factor(ID))
if(!grepl('phase', varNames[tt])){
curLM = lm(dv ~ age + sex + diag  +IQ , data = modDat)
aovTab = Anova(curLM, type = 3)
ai = (ii-2)*length(varNames)
results[tt+ai,1] = varNames[tt]
ei = which(row.names(aovTab) == 'Residuals')
ri = which(row.names(aovTab) == 'diag')
results$Diag[tt+ai] = aovTab$`Sum Sq`[ri] / (aovTab$`Sum Sq`[ri] + aovTab$`Sum Sq`[ei])
ri = which(row.names(aovTab) == 'sex')
results$sex[tt+ai] = aovTab$`Sum Sq`[ri] / (aovTab$`Sum Sq`[ri] + aovTab$`Sum Sq`[ei])
ri = which(row.names(aovTab) == 'IQ')
results$IQ[tt+ai] = aovTab$`Sum Sq`[ri] / (aovTab$`Sum Sq`[ri] + aovTab$`Sum Sq`[ei])
ri = which(row.names(aovTab) == 'age')
results$age[tt+ai] = aovTab$`Sum Sq`[ri] / (aovTab$`Sum Sq`[ri] + aovTab$`Sum Sq`[ei])
ri = which(names(curLM$coefficients) == 'age')
results$age_b[tt+ai] = curLM$coefficients[[ri]]
ri = which(names(curLM$coefficients) == 'sexM')
results$sex_b[tt+ai] = curLM$coefficients[[ri]]
ri = which(names(curLM$coefficients) == 'IQ')
results$IQ_b[tt+ai] = curLM$coefficients[[ri]]
ri = which(names(curLM$coefficients) == 'diag2')
results$diag_b1[tt+ai] = curLM$coefficients[[ri]]
ri = which(names(curLM$coefficients) == 'diag3')
results$diag_b2[tt+ai] = curLM$coefficients[[ri]]
}else { #phase needs to be treated differently because it's circular
circdv = circular(dv, unit = 'degrees')
dv_mean =  mean(circdv)[[1]]
dv_sd = sd(circdv)[[1]]
test = cbind(cos(dv*(pi/180)), sin(dv*(pi/180)))
curLM = lm(test ~ modDat$age + modDat$sex + modDat$diag  + modDat$IQ )
aovTab = Anova(curLM, type = 3)
outtests <- car:::print.Anova.mlm
body(outtests)[[16]] <- quote(invisible(tests))
body(outtests)[[15]] <- NULL
tab <- lapply(c("Pillai"),
function(i)  outtests(Anova(curLM, test.statistic=i)))
tab <- do.call(rbind, tab)
#working out effect size for diag
ai = (ii-2)*length(varNames)
ri = which(grepl('diag', row.names(tab)))
results[tt+ai,1] = varNames[tt]
results$Diag[tt+ai] = (tab$Df[1] * tab$`approx F`[ri]) /
(tab$Df[ri] * tab$`approx F`[ri] + tab$`den Df`[ri])
ri = which(grepl('sex', row.names(tab)))
results$sex[tt+ai] = (tab$Df[1] * tab$`approx F`[ri]) /
(tab$Df[ri] * tab$`approx F`[ri] + tab$`den Df`[ri])
ri = which(grepl('IQ', row.names(tab)))
results$IQ[tt+ai] = (tab$Df[1] * tab$`approx F`[ri]) /
(tab$Df[ri] * tab$`approx F`[ri] + tab$`den Df`[ri])
ri = which(grepl('age', row.names(tab)))
results$age[tt+ai] = (tab$Df[1] * tab$`approx F`[ri]) /
(tab$Df[ri] * tab$`approx F`[ri] + tab$`den Df`[ri])
}
#shared outputs for phase and other
results$n[tt+ai] = n
results$out[tt+ai] = n-length(dv)
results$ageGroup[tt+ai] = ii-1
results$dvMean[tt+ai] = dv_mean
results$dvSD[tt+ai] = dv_sd
}
}
}
resultsTEST = results
resultsDif = data.frame('dependentVariable' = resultsTEST$dependentVariable,
'age' = abs(resultsTEST$age - resultsTRAIN$age) / (resultsTEST$age + resultsTRAIN$age),
'sex' = abs(resultsTEST$sex - resultsTRAIN$sex) / (resultsTEST$sex + resultsTRAIN$sex),
'IQ' = abs(resultsTEST$IQ - resultsTRAIN$IQ) / (resultsTEST$IQ + resultsTRAIN$IQ),
'Diag' = abs(resultsTEST$Diag - resultsTRAIN$Diag) / (resultsTEST$Diag + resultsTRAIN$Diag),
'ageGroup' = resultsTEST$ageGroup )
resultsDif = filter(resultsDif, resultsTEST$dependentVariable != 'A')
resultsTEST = filter(resultsTEST, dependentVariable != 'A')
resultsTRAIN = filter(resultsTRAIN, dependentVariable != 'A')
resultsDif$type = 'A'
resultsDif$type[apply(as.matrix(resultsDif$dependentVariable),
1, function(x) grepl('pow', x, ignore.case = T))] = 'power'
resultsDif$type[apply(as.matrix(resultsDif$dependentVariable),
1, function(x) grepl('slope', x, ignore.case = T))] = 'slope'
resultsDif$type[apply(as.matrix(resultsDif$dependentVariable),
1, function(x) grepl('relalpha', x, ignore.case = T) |
grepl('logalpha', x, ignore.case = T))] = 'alpha'
resultsDif$type[apply(as.matrix(resultsDif$dependentVariable),
1, function(x) grepl('sampEnt', x, ignore.case = T))] = 'sampEnt'
resultsDif$type[apply(as.matrix(resultsDif$dependentVariable),
1, function(x) grepl('ispc', x, ignore.case = T))] = 'ispc'
resultsDif$type[apply(as.matrix(resultsDif$dependentVariable),
1, function(x) grepl('PAC', x, ignore.case = T))] = 'PAC'
resultsDif$type[apply(as.matrix(resultsDif$dependentVariable),
1, function(x) grepl('phase', x, ignore.case = T))] = 'phase'
resultsTRAIN$type = 'A'
resultsTRAIN$type[apply(as.matrix(resultsTRAIN$dependentVariable),
1, function(x) grepl('pow', x, ignore.case = T))] = 'power'
resultsTRAIN$type[apply(as.matrix(resultsTRAIN$dependentVariable),
1, function(x) grepl('slope', x, ignore.case = T))] = 'slope'
resultsTRAIN$type[apply(as.matrix(resultsTRAIN$dependentVariable),
1, function(x) grepl('relalpha', x, ignore.case = T) |
grepl('logalpha', x, ignore.case = T))] = 'alpha'
resultsTRAIN$type[apply(as.matrix(resultsTRAIN$dependentVariable),
1, function(x) grepl('sampEnt', x, ignore.case = T))] = 'sampEnt'
resultsTRAIN$type[apply(as.matrix(resultsTRAIN$dependentVariable),
1, function(x) grepl('ispc', x, ignore.case = T))] = 'ispc'
resultsTRAIN$type[apply(as.matrix(resultsTRAIN$dependentVariable),
1, function(x) grepl('PAC', x, ignore.case = T))] = 'PAC'
resultsTRAIN$type[apply(as.matrix(resultsTRAIN$dependentVariable),
1, function(x) grepl('phase', x, ignore.case = T))] = 'phase'
#### general graphics params ####
ageLabs = c(paste(as.character(min(filter(dat, age>ageGroups[1] & age<ageGroups[2])$age)), '-',
as.character(max(filter(dat, age>ageGroups[1] & age<ageGroups[2])$age)),
' months', sep = ''),
paste(as.character(min(filter(dat, age>ageGroups[2] & age<ageGroups[3])$age)), '-',
as.character(max(filter(dat, age>ageGroups[2] & age<ageGroups[3])$age)),
' months', sep = ''),
paste(as.character(min(filter(dat, age>ageGroups[3] & age<ageGroups[4])$age)), '-',
as.character(max(filter(dat, age>ageGroups[3] & age<ageGroups[4])$age)),
' months', sep = ''))
names(ageLabs) <- c('1', '2', '3')
myColors = c('#F22F29','#CD4D5D', '#FB9564', '#4ED6B2','#2C64C0', '#1B47A5',    '#7B5C52')
names(myColors) <- levels(factor(resultsTRAIN$type))
colScale <- scale_color_manual(name = "type",values = myColors)
fillScale <- scale_fill_manual(name = "type",values = myColors)
theme_set(theme_gray(base_size = 30))
#### plotting the effect size values ####
thresh = .00
predNames = c('age', 'sex', 'IQ', 'Diag')
n = length(resultsDif$age)
allEffects = data.frame('agreement' = c(resultsDif$age, resultsDif$sex, resultsDif$IQ, resultsDif$Diag),
'effectSize' = c(resultsTRAIN$age, resultsTRAIN$sex, resultsTRAIN$IQ, resultsTRAIN$Diag),
'predictor' = c(rep('age', n), rep('sex', n), rep('IQ', n), rep('diagnosis', n)))
outPlot <-ggplot(allEffects, aes(x=agreement, y=effectSize, color = predictor)) +
geom_jitter(size = 5, alpha = .5)+
theme_classic(base_size = 30)+
theme(axis.ticks.length=unit(-0.5, "cm"),
axis.line = element_line(colour = 'black', size = 3),
axis.ticks = element_line(colour = 'black', size = 3),
legend.position = c(0.67, 0.8)) +
guides(color = guide_legend(override.aes = list(size=10),
nrow=4)) +
ylab('effect size (\U1D702\U00B2\U209A)') +
scale_x_continuous(expand = c(0, 0), limits = c(0, 1.01), breaks = seq(0,1,.25)) +
scale_y_continuous(expand = c(0, 0), limits = c(0, .65), breaks = seq(0,.65,.1))
print(outPlot)
dat2 = read.csv("C:\\Users\\Adam Dede\\Documents\\GitHub\\SheffieldAutismBiomarkers\\trainSet.csv")
dat2 <- dat2 %>% select(-X)
comboDat = rbind(dat2, dat)
comboDat$ageGroup = 1
comboDat$ageGroup[comboDat$age>ageGroups[2]] = 2
comboDat$ageGroup[comboDat$age>ageGroups[3]] = 3
test = comboDat[,(grepl('logAlpha', names(comboDat)) | grepl('relAlpha', names(comboDat)))]
sum(apply(as.matrix(test), 1, function(x) sum(is.na(x)))> 0) #how many participants had at least one miss?
sum(apply(as.matrix(test), 1, function(x) sum(is.na(x)))> 5) #how many participants had more than 5 misses?
1-sum(apply(as.matrix(test), 1, function(x) sum(is.na(x))))/(776*36) #what proportion were well fit?
vari = 4
temp = resultsDif[resultsDif$ageGroup == agei,]
tempRes = resultsTRAIN[resultsDif$ageGroup == agei,]
candidates = which(temp[predNames[vari]] < .2 & tempRes[predNames[vari]] > thresh)
target = candidates[which(tempRes[candidates,predNames[vari]]==max(tempRes[candidates,predNames[vari]]))]
predNames2 = predNames
predNames2[4] = 'group'
vari = 4
agei = 1
temp = resultsDif[resultsDif$ageGroup == agei,]
tempRes = resultsTRAIN[resultsDif$ageGroup == agei,]
candidates = which(temp[predNames[vari]] < .2 & tempRes[predNames[vari]] > thresh)
target = candidates[which(tempRes[candidates,predNames[vari]]==max(tempRes[candidates,predNames[vari]]))]
